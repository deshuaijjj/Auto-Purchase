import pyautogui
import time
import logging
from typing import Dict, Tuple, Optional

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# å®‰å…¨è®¾ç½®
pyautogui.FAILSAFE = True
pyautogui.PAUSE = 0  # æ— å»¶è¿Ÿ


class DebugTicketGrabber:
    """è°ƒè¯•æ¨¡å¼æŠ¢ç¥¨ç³»ç»Ÿ - åˆ†æ­¥æµ‹è¯•"""
    
    def __init__(self):
        self.click_positions: Dict[str, Tuple[int, int]] = {}
        self.step_delay = 3  # æ¯æ­¥ä¹‹é—´çš„å»¶è¿Ÿï¼ˆç§’ï¼‰ï¼Œæ–¹ä¾¿è§‚å¯Ÿæ•ˆæœ
        
    def load_config(self):
        """ä»é…ç½®æ–‡ä»¶åŠ è½½åæ ‡"""
        import sys
        import os
        
        # è·å–å½“å‰è„šæœ¬æ‰€åœ¨ç›®å½•
        current_dir = os.path.dirname(os.path.abspath(__file__))
        
        # æ·»åŠ å½“å‰ç›®å½•åˆ°Pythonè·¯å¾„
        if current_dir not in sys.path:
            sys.path.insert(0, current_dir)
        
        try:
            # æ£€æŸ¥config.pyæ˜¯å¦å­˜åœ¨
            config_path = os.path.join(current_dir, 'config.py')
            if not os.path.exists(config_path):
                logger.error(f"âŒ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}")
                logger.error("   è¯·ç¡®ä¿ config.py æ–‡ä»¶ä¸è°ƒè¯•æ¨¡å¼.pyåœ¨åŒä¸€ç›®å½•")
                return False
            
            # å¯¼å…¥é…ç½®
            import config
            if not hasattr(config, 'CLICK_POSITIONS'):
                logger.error("âŒ config.py ä¸­ç¼ºå°‘ CLICK_POSITIONS é…ç½®")
                return False
            
            self.click_positions = config.CLICK_POSITIONS.copy()
            logger.info("âœ… é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ")
            logger.info(f"   é…ç½®æ–‡ä»¶è·¯å¾„: {config_path}")
            logger.info(f"   å·²åŠ è½½ {len(self.click_positions)} ä¸ªåæ ‡")
            
            # æ˜¾ç¤ºåŠ è½½çš„åæ ‡
            for name, pos in self.click_positions.items():
                logger.info(f"      - {name}: {pos}")
            
            return True
            
        except ImportError as e:
            logger.error(f"âŒ æ— æ³•å¯¼å…¥é…ç½®æ–‡ä»¶")
            logger.error(f"   é”™è¯¯è¯¦æƒ…: {e}")
            logger.error(f"   è¯·ç¡®ä¿ config.py æ–‡ä»¶å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®")
            import traceback
            traceback.print_exc()
            return False
        except SyntaxError as e:
            logger.error(f"âŒ config.py æ–‡ä»¶è¯­æ³•é”™è¯¯: {e}")
            logger.error(f"   è¯·æ£€æŸ¥é…ç½®æ–‡ä»¶æ ¼å¼")
            return False
        except Exception as e:
            logger.error(f"âŒ åŠ è½½é…ç½®æ—¶å‡ºé”™: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def show_current_mouse_position(self):
        """æ˜¾ç¤ºå½“å‰é¼ æ ‡ä½ç½®"""
        x, y = pyautogui.position()
        logger.info(f"ğŸ“ å½“å‰é¼ æ ‡ä½ç½®: ({x}, {y})")
        return (x, y)
    
    def test_single_button(self, button_name: str, position: Tuple[int, int], delay: int = 3):
        """
        æµ‹è¯•å•ä¸ªæŒ‰é’®çš„ç‚¹å‡»
        
        :param button_name: æŒ‰é’®åç§°
        :param position: åæ ‡ (x, y)
        :param delay: ç‚¹å‡»å‰çš„å€’è®¡æ—¶ï¼ˆç§’ï¼‰
        """
        x, y = position
        
        logger.info("=" * 60)
        logger.info(f"ğŸ§ª æµ‹è¯•æŒ‰é’®: {button_name}")
        logger.info(f"   åæ ‡: ({x}, {y})")
        logger.info(f"   â±ï¸  {delay} ç§’åç‚¹å‡»ï¼Œè¯·è§‚å¯Ÿ...")
        logger.info("=" * 60)
        
        # å€’è®¡æ—¶
        for i in range(delay, 0, -1):
            print(f"   å€’è®¡æ—¶: {i} ç§’...", end='\r')
            time.sleep(1)
        print("   " * 20)  # æ¸…ç©ºå€’è®¡æ—¶è¡Œ
        
        try:
            # ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆå¯é€‰ï¼Œç”¨äºå¯è§†åŒ–ï¼‰
            pyautogui.moveTo(x, y, duration=0.2)
            time.sleep(0.2)
            
            # æ‰§è¡Œç‚¹å‡»
            start_time = time.time()
            pyautogui.click(x, y, duration=0)
            click_time = (time.time() - start_time) * 1000
            
            logger.info(f"âœ… ç‚¹å‡»å®Œæˆï¼è€—æ—¶: {click_time:.2f}ms")
            logger.info(f"   è¯·æ£€æŸ¥æŒ‰é’®æ˜¯å¦è¢«æ­£ç¡®ç‚¹å‡»")
            logger.info("")
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ ç‚¹å‡»å¤±è´¥: {e}")
            return False
    
    def test_all_buttons_sequential(self, step_delay: int = 3):
        """
        æŒ‰é¡ºåºæµ‹è¯•æ‰€æœ‰æŒ‰é’®ï¼ˆåˆ†æ­¥æ‰§è¡Œï¼‰
        
        :param step_delay: æ¯æ­¥ä¹‹é—´çš„å»¶è¿Ÿï¼ˆç§’ï¼‰
        """
        if not self.click_positions:
            logger.error("âŒ æ²¡æœ‰åŠ è½½ä»»ä½•åæ ‡ï¼Œè¯·å…ˆè°ƒç”¨ load_config()")
            return
        
        logger.info("=" * 60)
        logger.info("ğŸš€ å¼€å§‹åˆ†æ­¥æµ‹è¯•æ¨¡å¼")
        logger.info("=" * 60)
        logger.info(f"   å°†æŒ‰é¡ºåºæµ‹è¯• {len(self.click_positions)} ä¸ªæŒ‰é’®")
        logger.info(f"   æ¯æ­¥ä¹‹é—´æœ‰ {step_delay} ç§’å»¶è¿Ÿï¼Œæ–¹ä¾¿è§‚å¯Ÿæ•ˆæœ")
        logger.info("   æç¤ºï¼šå°†é¼ æ ‡ç§»åŠ¨åˆ°å±å¹•è§’è½å¯ä»¥ç´§æ€¥åœæ­¢")
        logger.info("")
        
        input("æŒ‰å›è½¦é”®å¼€å§‹æµ‹è¯•...")
        logger.info("")
        
        results = {}
        
        # æŒ‰é¡ºåºæµ‹è¯•æ¯ä¸ªæŒ‰é’®
        button_order = ['ç«‹å³è´­ç¥¨', 'åœºæ¬¡', 'ç¥¨æ¡£', 'ç¡®è®¤', 'æäº¤']
        
        for i, button_name in enumerate(button_order, 1):
            if button_name not in self.click_positions:
                logger.warning(f"â­ï¸  è·³è¿‡ '{button_name}' (æœªé…ç½®)")
                continue
            
            position = self.click_positions[button_name]
            
            logger.info(f"\næ­¥éª¤ {i}/{len([b for b in button_order if b in self.click_positions])}")
            success = self.test_single_button(button_name, position, delay=step_delay)
            results[button_name] = success
            
            # å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´å†ç»§ç»­
            if i < len([b for b in button_order if b in self.click_positions]):
                logger.info(f"â¸ï¸  ç­‰å¾… {step_delay} ç§’åç»§ç»­ä¸‹ä¸€ä¸ªæ­¥éª¤...")
                time.sleep(step_delay)
        
        # æ˜¾ç¤ºæµ‹è¯•ç»“æœ
        logger.info("")
        logger.info("=" * 60)
        logger.info("ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»")
        logger.info("=" * 60)
        for button_name, success in results.items():
            status = "âœ… æˆåŠŸ" if success else "âŒ å¤±è´¥"
            position = self.click_positions[button_name]
            logger.info(f"   {button_name:10} {status} - åæ ‡: {position}")
        logger.info("=" * 60)
    
    def test_single_button_interactive(self):
        """äº¤äº’å¼æµ‹è¯•å•ä¸ªæŒ‰é’®"""
        if not self.click_positions:
            logger.error("âŒ æ²¡æœ‰åŠ è½½ä»»ä½•åæ ‡ï¼Œè¯·å…ˆè°ƒç”¨ load_config()")
            return
        
        logger.info("=" * 60)
        logger.info("ğŸ¯ äº¤äº’å¼å•æŒ‰é’®æµ‹è¯•")
        logger.info("=" * 60)
        logger.info("å¯ç”¨æŒ‰é’®ï¼š")
        
        buttons = list(self.click_positions.keys())
        for i, button_name in enumerate(buttons, 1):
            position = self.click_positions[button_name]
            logger.info(f"   {i}. {button_name} - åæ ‡: {position}")
        
        logger.info("")
        
        try:
            choice = input("è¯·é€‰æ‹©è¦æµ‹è¯•çš„æŒ‰é’®ï¼ˆè¾“å…¥æ•°å­—æˆ–åç§°ï¼Œå›è½¦é€€å‡ºï¼‰: ").strip()
            
            if not choice:
                return
            
            # å°è¯•æŒ‰æ•°å­—é€‰æ‹©
            if choice.isdigit():
                index = int(choice) - 1
                if 0 <= index < len(buttons):
                    button_name = buttons[index]
                else:
                    logger.error("âŒ æ— æ•ˆçš„é€‰æ‹©")
                    return
            else:
                # æŒ‰åç§°é€‰æ‹©
                if choice in self.click_positions:
                    button_name = choice
                else:
                    logger.error(f"âŒ æœªæ‰¾åˆ°æŒ‰é’®: {choice}")
                    return
            
            position = self.click_positions[button_name]
            delay = int(input("ç‚¹å‡»å‰å€’è®¡æ—¶ï¼ˆç§’ï¼Œé»˜è®¤3ç§’ï¼‰: ") or "3")
            
            self.test_single_button(button_name, position, delay)
            
        except KeyboardInterrupt:
            logger.info("\nâš ï¸ ç”¨æˆ·å–æ¶ˆ")
        except ValueError:
            logger.error("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
    
    def test_button_by_coordinate(self):
        """é€šè¿‡è¾“å…¥åæ ‡æµ‹è¯•æŒ‰é’®"""
        logger.info("=" * 60)
        logger.info("ğŸ“ åæ ‡æµ‹è¯•æ¨¡å¼")
        logger.info("=" * 60)
        logger.info("æç¤ºï¼šå¯ä»¥ä½¿ç”¨é¼ æ ‡ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œç„¶åæŒ‰å¿«æ·é”®è·å–åæ ‡")
        
        try:
            x_input = input("è¯·è¾“å…¥ X åæ ‡ï¼ˆæˆ–æŒ‰å›è½¦ä½¿ç”¨å½“å‰é¼ æ ‡ä½ç½®ï¼‰: ").strip()
            y_input = input("è¯·è¾“å…¥ Y åæ ‡ï¼ˆæˆ–æŒ‰å›è½¦ä½¿ç”¨å½“å‰é¼ æ ‡ä½ç½®ï¼‰: ").strip()
            
            if not x_input or not y_input:
                # ä½¿ç”¨å½“å‰é¼ æ ‡ä½ç½®
                x, y = pyautogui.position()
                logger.info(f"ğŸ“ ä½¿ç”¨å½“å‰é¼ æ ‡ä½ç½®: ({x}, {y})")
            else:
                x, y = int(x_input), int(y_input)
            
            delay = int(input("ç‚¹å‡»å‰å€’è®¡æ—¶ï¼ˆç§’ï¼Œé»˜è®¤3ç§’ï¼‰: ") or "3")
            
            self.test_single_button("æµ‹è¯•åæ ‡", (x, y), delay)
            
        except ValueError:
            logger.error("âŒ åæ ‡å¿…é¡»æ˜¯æ•°å­—")
        except KeyboardInterrupt:
            logger.info("\nâš ï¸ ç”¨æˆ·å–æ¶ˆ")
    
    def preview_all_positions(self):
        """é¢„è§ˆæ‰€æœ‰åæ ‡ä½ç½®ï¼ˆä»…ç§»åŠ¨é¼ æ ‡ï¼Œä¸ç‚¹å‡»ï¼‰"""
        if not self.click_positions:
            logger.error("âŒ æ²¡æœ‰åŠ è½½ä»»ä½•åæ ‡")
            return
        
        logger.info("=" * 60)
        logger.info("ğŸ‘€ åæ ‡é¢„è§ˆæ¨¡å¼ï¼ˆä»…ç§»åŠ¨é¼ æ ‡ï¼Œä¸ç‚¹å‡»ï¼‰")
        logger.info("=" * 60)
        logger.info("   é¼ æ ‡å°†ä¾æ¬¡ç§»åŠ¨åˆ°æ¯ä¸ªæŒ‰é’®çš„ä½ç½®ï¼Œä¾¿äºè§‚å¯Ÿ")
        logger.info("")
        
        input("æŒ‰å›è½¦é”®å¼€å§‹é¢„è§ˆ...")
        
        for button_name, position in self.click_positions.items():
            x, y = position
            logger.info(f"ğŸ“ {button_name}: ç§»åŠ¨åˆ° ({x}, {y})")
            pyautogui.moveTo(x, y, duration=0.5)
            time.sleep(2)  # åœç•™2ç§’
        
        logger.info("\nâœ… é¢„è§ˆå®Œæˆ")


def main():
    """ä¸»å‡½æ•°"""
    print("=" * 60)
    print("ğŸ› å¿«é€ŸæŠ¢ç¥¨ç³»ç»Ÿ - è°ƒè¯•æ¨¡å¼")
    print("=" * 60)
    print()
    
    # åˆ›å»ºè°ƒè¯•å®ä¾‹
    debug = DebugTicketGrabber()
    
    # åŠ è½½é…ç½®
    if not debug.load_config():
        print("\nâŒ æ— æ³•åŠ è½½é…ç½®ï¼Œç¨‹åºé€€å‡º")
        return
    
    print("\nå¯ç”¨åŠŸèƒ½ï¼š")
    print("1. åˆ†æ­¥æµ‹è¯•æ‰€æœ‰æŒ‰é’®ï¼ˆæŒ‰é¡ºåºé€ä¸ªæµ‹è¯•ï¼‰")
    print("2. äº¤äº’å¼æµ‹è¯•å•ä¸ªæŒ‰é’®")
    print("3. æµ‹è¯•æŒ‡å®šåæ ‡")
    print("4. é¢„è§ˆæ‰€æœ‰åæ ‡ä½ç½®ï¼ˆä»…ç§»åŠ¨é¼ æ ‡ï¼‰")
    print("5. æ˜¾ç¤ºå½“å‰é¼ æ ‡ä½ç½®")
    print("0. é€€å‡º")
    print()
    
    while True:
        try:
            choice = input("è¯·é€‰æ‹©åŠŸèƒ½ (0-5): ").strip()
            
            if choice == '0':
                print("ğŸ‘‹ å†è§ï¼")
                break
            elif choice == '1':
                delay = input("æ¯æ­¥å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼Œé»˜è®¤3ç§’ï¼‰: ").strip()
                delay = int(delay) if delay else 3
                debug.test_all_buttons_sequential(step_delay=delay)
            elif choice == '2':
                debug.test_single_button_interactive()
            elif choice == '3':
                debug.test_button_by_coordinate()
            elif choice == '4':
                debug.preview_all_positions()
            elif choice == '5':
                debug.show_current_mouse_position()
            else:
                print("âŒ æ— æ•ˆçš„é€‰æ‹©ï¼Œè¯·é‡æ–°è¾“å…¥")
            
            print()
            
        except KeyboardInterrupt:
            print("\n\nâš ï¸ ç”¨æˆ·ä¸­æ–­ï¼Œé€€å‡ºç¨‹åº")
            break
        except Exception as e:
            print(f"âŒ å‘ç”Ÿé”™è¯¯: {e}")


if __name__ == "__main__":
    main()


